#include "myLib.h"
#include "spritedemo16.h"
#include "background.h"

// Comment out this line to see alternate sprite
#define BLOCK

#define WIDTHMIN -70		/* Change to negative to see bug */
#define WIDTHMAX 300

#define HEIGHTMIN -70
#define HEIGHTMAX 250

#define ROWMASK (0xFF)
#define COLMASK (0x1FF)

//// Uncomment these two lines to see the bug!!!!!
//#define ROWMASK (0xFFFFFFFF)
//#define COLMASK (0xFFFFFFFF)


// Note: This is just for 4 bpp
#define SPRITEOFFSET16(r,c) (r)*32+(c)

#define NUMSPRITES 12

// Structure to hold critical information about sprites
typedef struct {
    int row;
    int col;
    int start;
    int shape;
    int size;
    int height;
    int width;
    int rdel;
    int cdel;
    int palette_bank;
} Sprite;



int main(void)
{
    int i;
    
    OamEntry shadowOAM[128];

    /* Information about each sprite */
    Sprite sprites[NUMSPRITES] =
    {{10,5,SPRITE64X64_ID,ATTR0_SQUARE,ATTR1_SIZE64,64,64,1,1,SPRITE64X64_PALETTE},
    {90,5,SPRITE32X32_ID,ATTR0_SQUARE,ATTR1_SIZE32,32,32,-1,1,SPRITE32X32_PALETTE},
#ifdef BLOCK
    {10,70,SPRITE16X16_ID,ATTR0_SQUARE,ATTR1_SIZE16,16,16,1,-1,SPRITE16X16_PALETTE}, 
#else
    {10,70,THING_ID,ATTR0_SQUARE,ATTR1_SIZE16,16,16,1,-1,THING_PALETTE}, 
#endif
    {90,40,SPRITE8X8_ID,ATTR0_SQUARE,ATTR1_SIZE8,8,8,-1,-1,SPRITE8X8_PALETTE},
    {10,90,SPRITE16X8_ID,ATTR0_WIDE,ATTR1_SIZE8,8,16,1,-1,SPRITE16X8_PALETTE},
    {90,60,SPRITE32X8_ID,ATTR0_WIDE,ATTR1_SIZE16,8,32,-1,-1,SPRITE32X8_PALETTE},
    {10,130,SPRITE32X16_ID,ATTR0_WIDE,ATTR1_SIZE32,16,32,1,1,SPRITE32X16_PALETTE},
    {90,100,SPRITE64X32_ID,ATTR0_WIDE,ATTR1_SIZE64,32,64,-1,1,SPRITE64X32_PALETTE},
    {10,170,SPRITE8X16_ID,ATTR0_TALL,ATTR1_SIZE8,16,8,1,1,SPRITE8X16_PALETTE},
    {90,170,SPRITE8X32_ID,ATTR0_TALL,ATTR1_SIZE16,32,8,-1,-1,SPRITE8X32_PALETTE},
    {10,200,SPRITE16X32_ID,ATTR0_TALL,ATTR1_SIZE32,32,16,1,-1,SPRITE16X32_PALETTE},
    {90,200,SPRITE32X64_ID,ATTR0_TALL,ATTR1_SIZE64,64,32,-1,1,SPRITE32X64_PALETTE}};

    
    REG_DISPCTL = MODE0 | BG0_ENABLE | OBJ_ENABLE;

    // Load background palette
    for(i=0; i<BACKGROUND_PALETTE_SIZE; i++)
    {
        PALETTE[i] = background_palette[i];
    }
    
    // Load background tile images
    for(i=0; i<BACKGROUND_TILES_SIZE; i++)
    {
        CHARBLOCKBASE[0].tileimg[i] = background_tiles[i];
    }
    
    // Load background tile map
    for(i=0; i<BACKGROUND_MAP_SIZE; i++)
    {
        SCREENBLOCKBASE[28].tilemap[i] = background_map[i];
    }

    //background 0 control register: user screen block 30 for the tile map
    //and char block 0 for the tile images, in 256 color mode
    // 111111
    // 5432109876543210
    // SZ                <--- BG_SIZEX: 00 32x32
    //                                  01 64x32
    //                                  10 32x64
    //                                  11 64x64
    //   <SBB >
    //             <>    <--- CBB
    //         1         <---- 1-256 colors   0-16 palettes of 16 colors
    REG_BG0CNT = SBB(28) | CBB(0) | COLOR256 | BG_SIZE0;
    
    // Load sprite palette
    for(i=0; i< SPRITEDEMO16_PALETTE_SIZE; i++)
    {
        SPRITEPAL[i] = spritedemo16_palette[i];
    }
    
    // Load sprite images
    for(i=0; i<SPRITEDEMO16_SIZE; i++)
    {
        CHARBLOCKBASE[4].tileimg[i] = spritedemo16[i];
    }
    
    // Set attributes for all active sprites
    for(i=0; i<NUMSPRITES; i++)
    {
        shadowOAM[i].attr0 = sprites[i].row | ATTR0_4BPP | sprites[i].shape;
        shadowOAM[i].attr1 = sprites[i].col | sprites[i].size;
        shadowOAM[i].attr2 = sprites[i].start | sprites[i].palette_bank;
    }
    
    // Hide all inactive sprites
	
    for(i=NUMSPRITES; i<128; i++)
    {
        shadowOAM[i].attr0 = ATTR0_HIDE;
    }
	
    
   
	waitForVblank();
	
    // Copy shadow into real
	/*
	   for(i=0; i<NUMSPRITES; i++)		  // This doesn't work on some platforms because
       {                                  // the code generated by the compiler
           SPRITEMEM[i] = shadowOAM[i];   // tries to copy the structs byte by byte
       }                                  // but the memory only allows 16 bit operations
	   */                                 // (i.e. shorts). So we use DMA instead.
	
	DMA[3].src = shadowOAM;
	DMA[3].dst = SPRITEMEM;
	DMA[3].cnt = (128*sizeof(OamEntry)/2) | DMA_ON;

   while(!KEY_DOWN_NOW(BUTTON_START));
   while(1)
   {
       // Update locations
       for(i=0; i<NUMSPRITES; i++)
       {
           sprites[i].row = sprites[i].row + sprites[i].rdel;
           sprites[i].col = sprites[i].col + sprites[i].cdel;
           if(sprites[i].row < HEIGHTMIN)
           {
               sprites[i].row = HEIGHTMIN;
               sprites[i].rdel = -sprites[i].rdel;
           }
           if(sprites[i].col < WIDTHMIN)
           {
               sprites[i].col = WIDTHMIN;
               sprites[i].cdel = -sprites[i].cdel;
           }
           if(sprites[i].row + sprites[i].height > HEIGHTMAX)
           {
               sprites[i].row = HEIGHTMAX - sprites[i].height;
               sprites[i].rdel = -sprites[i].rdel;
           }
           if(sprites[i].col + sprites[i].width > WIDTHMAX)
           {
               sprites[i].col = WIDTHMAX - sprites[i].width;
               sprites[i].cdel = -sprites[i].cdel;
           }
       } // for(i=0; i<NUMSPRITES; i++)
       
       // Move data from sprite data structures into Shadow OAM
       for(i=0; i<NUMSPRITES; i++)
       {
            shadowOAM[i].attr0 = (ROWMASK&sprites[i].row) | ATTR0_4BPP | sprites[i].shape;
            shadowOAM[i].attr1 = (COLMASK&sprites[i].col) | sprites[i].size;
            shadowOAM[i].attr2 = sprites[i].start | sprites[i].palette_bank;
       }
       waitForVblank();
      

       // Copy shadow OAM into real OAM
	   /*
       for(i=0; i<NUMSPRITES; i++)        // This doesn't work on some platforms because
       {                                  // the code generated by the compiler
           SPRITEMEM[i] = shadowOAM[i];   // tries to copy the structs byte by byte
       }                                  // but the memory only allows 16 bit operations
	   */                                 // (i.e. shorts). So we use DMA instead
		DMA[3].src = shadowOAM;
		DMA[3].dst = SPRITEMEM;
		DMA[3].cnt = (NUMSPRITES*sizeof(OamEntry)/2) | DMA_ON;

   } // while

   return 0;
}

